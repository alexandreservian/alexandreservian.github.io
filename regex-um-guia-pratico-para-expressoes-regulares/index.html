<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.22.9"/><title data-react-helmet="true"></title><link rel="icon" href="/favicon-32x32.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#000000"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=a60a3bb6e12e0e61069e34d74e3bead3"/><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><link as="script" rel="preload" href="/webpack-runtime-72a1a1ce12b6759a1f7f.js"/><link as="script" rel="preload" href="/framework-e84382e1b96b75949e61.js"/><link as="script" rel="preload" href="/app-7c6c550acc932a22ff69.js"/><link as="script" rel="preload" href="/component---src-templates-post-index-js-a71a4067e82206d7c3bb.js"/><link as="fetch" rel="preload" href="/page-data/regex-um-guia-pratico-para-expressoes-regulares/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="blog-post"><h1>Regex: Um guia prático para expressões regulares</h1><h2>January 31, 2020</h2><div class="blog-post-content"><p>Em toda nossa vida como programadores estaremos lidando com <strong>regex</strong> em algum momento. Seja para coisas comuns como <strong>validar</strong> emails ou data e até mesmo para fazer <strong>parse</strong> em textos em busca de um determinado padrão.</p>
<p>Nesse post, irei mostrar de forma simples e fácil como você pode criar suas próprias expressões regulares. Todos os exemplos serão feitos usando <strong>javascript</strong>, porém, muito das regex criadas aqui também funcionarão em outras linguagens como <strong>elixir</strong>, <strong>python</strong>, <strong>php</strong> ou <strong>ruby</strong>.</p>
<hr>
<h2>O que é uma expressão regular?</h2>
<p>De forma simples:</p>
<blockquote>
<p>Uma expressão regular é um método formal de se especificar um padrão de texto.</p>
</blockquote>
<p>Com ela podemos lidar com as seguintes situações:</p>
<ul>
<li>procura;</li>
<li>substituição;</li>
<li>validação de formatos;</li>
<li>filtragem de informações</li>
</ul>
<h2>Criando nossas primeiras regex</h2>
<p>Usando javascript podemos optar por duas formas de se criar uma regex. Podemos criar usando um <strong>constructor</strong>:</p>
<pre><code class="language-js">const regex = new RegExp("dog", "gi")
</code></pre>
<p>Ou criando de forma <strong>literal</strong>:</p>
<pre><code class="language-js">const regex = /dog/gi
</code></pre>
<p>Podemos buscar por somente uma letra:</p>
<pre><code>pattern: /a/
string:  A casa está limpa.
matches:    ^
</code></pre>
<p>Ou buscar por uma palavra:</p>
<pre><code>pattern: /celular/
string:  O celular está tocando.
matches:   ^^^^^^^
</code></pre>
<p>Podemos ver que, na primeira regex, ela ignorou o primeiro <strong>A</strong>. Isso acontece porque as regex são <strong>case sensitive</strong>. Notamos também na primeira regex que só houve <strong>match</strong> na primeira ocorrência. Para lidar com isso, usaremos <strong>flags</strong>.</p>
<h2>Flags</h2>
<p>Elas adicionam comportamentos adicionais a nossas regras, como:</p>
<ul>
<li><code>g</code> - indicar achar todas as ocorrências da regex</li>
<li><code>i</code> - ignora case sensitive</li>
<li><code>m</code> - multilinha, lida com caracteres de inicio e fim <code>(^ e \$)</code> ao operar em múltiplas linhas.</li>
</ul>
<p>Podemos então obter todas as <strong>ocorrências</strong> com a flag <code>g</code> e em conjunto com a flag <code>i</code> podemos ignorar o <strong>case sensitive</strong> de uma busca:</p>
<pre><code>pattern: /ontem/gi
string: Ontem faltou água, Anteontem faltou luz
matches:^^^^^                  ^^^^^
</code></pre>
<h2>Operador pipe "|“</h2>
<p>Algumas vezes precisamos dar match em mais de <strong>um</strong> termo, para isso usamos o operador pipe <code>|</code> . Ele funciona basicamente como nosso operador lógico <strong>OR</strong> <code>||</code>. Assim podemos escrever:</p>
<pre><code>pattern: /ver|distrai/gi
string: Ver a linha do horizonte me distrai
matches:^^^                         ^^^^^^^

pattern: /20|nove/gi
string: Perdi 20 em 20 e nove amizades
matches:      ^^    ^^   ^^^^

pattern: /e|m|²/gi
string:  E = mc²
matches: ^   ^ ^
</code></pre>
<h2>Conjuntos “[]”</h2>
<p>Com os conjuntos dizemos a regex que uma determinada casa pode ter diversos valores para dar match. Vejamos o seu uso:</p>
<pre><code>pattern: /[em²]/gi
string:  E = mc²
matches: ^   ^ ^
</code></pre>
<p>Uma funcionalidade interessante é de adicionar <strong>range</strong> (invervalos) dentro dos nossos conjuntos. Podemos determinar um conjunto de match em letras que vão de <strong>A</strong> à <strong>Z</strong> ou pegue qualquer digito <strong>(0 à 9)</strong>.</p>
<pre><code>pattern: /[a-z]/
string:  João de Santo Cristo
matches:  ^ ^ ^^  ^^^^  ^^^^^

pattern: /[A-Za-z]/
string:  Açucar e Café
matches: ^ ^^^^ ^  ^^

pattern: /[0-9.,]/
string:  Um ps4 custa R$ 1.600,00
matches:      ^          ^^^^^^^^
</code></pre>
<p>Um detalhe a ser observado é que o <strong>range</strong> obedece a mesma ordem da tabela <strong><a href="https://unicode-table.com/pt/">Unicode</a></strong>, sendo assim regex como <code>[a-Z]</code> ou <code>[4-1]</code> produziram <strong>erro</strong>, pois ambas não estão na ordem correta da tabela Unicode.</p>
<p>Podemos também dar match em letras com <strong>acentos</strong> (é-à) ou (ç) usando:</p>
<pre><code>pattern: /[À-ü]/
string:  Açaí é melhor
matches: ^^^^ ^ ^^^^^^
</code></pre>
<p>Temos também os <strong>conjuntos negados</strong>, que como o nome sugere, dar match em tudo que não faça parte do conjunto. Para definí-lo iniciamos a regra do conjunto com <code>^</code> , por exemplo <code>[^a-z]</code> que aceita tudo que não seja entre <strong>a</strong> à <strong>z</strong>. Vejamos um exemplo:</p>
<pre><code>pattern: /[^aeiouí]/gi
string:  Paralelepípedo
matches: ^ ^ ^ ^ ^ ^ ^
</code></pre>
<h2>Metacaracteres</h2>
<p>Nas regex existem duas formas de caracteres, os <strong>literais</strong>, que representam o valor literal do caractere como <code>abc123</code> e os <strong>metacaracteres</strong> que possuem funções distintas dentro de um contexto na regex. Dois exemplos que acabamos de ver são o uso do <code>^</code> iniciando um conjunto negado e o uso do <code>-</code> em uma regra de conjunto com range <code>[1-9]</code>. Um metacaractere bastante recorrente é o <strong>ponto</strong> <code>.</code>, ele funciona como um <strong>coringa</strong>, sendo capaz de dar match em qualquer caractere, vejamos um exemplo:</p>
<pre><code>pattern: /cas./gi
string:  Casa, caso, case
matches: ^^^^  ^^^^  ^^^^
</code></pre>
<p>Visto isso, você deve estar se perguntando: Como pegar a forma <strong>literal</strong> do ponto? Eis que é muito simples bastando usar um <strong>escape</strong> <code>\</code> mais o metacaractere desejado. Vejamos um exemplo:</p>
<pre><code>pattern: /[a\-o]/gi
string:  cachorro-quente.
matches:  ^  ^  ^^
</code></pre>
<p>Para simplificar a escrita e leitura das regex, possuímos algumas <strong>shorthands</strong> que são extremamente úteis para deixar ainda mais claro nosso código. Veja como podemos escrever esse conjunto <code>[0-9]</code> para <code>\d</code>, <code>[a-zA-Z0-9_]</code> para <code>\w</code> ou para tratar espaços em branco <code>[\r\n\t\f\v ]</code> para <code>\s</code> simplificando ainda mais nossas regras. Vejamos alguns exemplos:</p>
<pre><code>pattern: /\(\d\d\)\s\d\d\d\d\d-\d\d\d\d/
string:  (86) 95262-7297
matches: ^^^^^^^^^^^^^^^

pattern: /\w\w\w\w\w@\w\w\.com/
string:  ax_a5@5x.com
matches: ^^^^^^^^^^^^
</code></pre>
<p>Para um guia de consulta, criei um <strong><a href="https://gist.github.com/alexandreservian/124db2fab8a75474dd6fdc4f17f93a5d">gist</a></strong> contendo muitos <strong>metacaracteres</strong> e shorthands e seus respectivos significado.</p>
<h2>Quantificadores</h2>
<p>Uma maneira de deixar suas regras ainda mais simples é com o uso dos quantificadores. Com eles podemos dizer quantas vezes uma <strong>mesma</strong> regra pode aparecer em <strong>sequência</strong>. Vejamos elas:</p>
<ul>
<li><code>?</code> - zero ou um ocorrência;</li>
<li><code>*</code> - zero ou mais ocorrências;</li>
<li><code>+</code> - uma ou mais ocorrências;</li>
<li><code>{n, m}</code> - de n até m.</li>
</ul>
<blockquote>
<p>Seu uso é simples, basta adicionar o quantificador após um caractere, metacaractere, conjunto ou mesmo um grupo (ainda veremos abaixo). Exemplo <code>[0-9]?</code> <code>\w\*</code> <code>a+</code> e <code>(\d){1,3}</code>.</p>
</blockquote>
<p>Digamos que queremos pegar um documento como o <strong>cpf</strong>, que contêm muitos números e pontuações(<code>.</code> e <code>-</code>) onde a validação pode aceitar o cpf com e sem pontuação, ficando deste modo:</p>
<pre><code>pattern: /\d{3}\.?\d{3}\.?\d{3}-?\d{2}/
string:  825.531.760-07
matches: ^^^^^^^^^^^^^^
string:  18646661024
matches: ^^^^^^^^^^^
</code></pre>
<p>Como podemos pegar uma repetição de caractere sem estipular algum limite, vejamos:</p>
<pre><code>pattern: /go+l+/gi
string:  Goolllll da Alemanha!!!
matches: ^^^^^^^^
</code></pre>
<h2>Âncoras</h2>
<p>Muitas vezes vamos precisar <strong>delimitar</strong> a ação da nossa regex. Desse modo podemos usar três metas para nos auxiliar nessa função.</p>
<p>Quando queremos tratar uma <strong>palavra</strong> que em suas extremidades não possua outra letra ou palavra, usamos a shorthands <code>\b</code>.</p>
<pre><code>pattern: /\bpar\b/gi
string:  Parcela par Parcial paraíso
matches:         ^^^

pattern: /\bpar[a-z]+/gi
string:  Parei parque topar
matches: ^^^^^ ^^^^^^

pattern: /[a-z]+par\b/gi
string:  parodiado escapar equipar parasitar
matches:           ^^^^^^^ ^^^^^^^

pattern: /\b[a-z]+par[a-z]+\b/gi
string:  limpar aparto aparta
matches:        ^^^^^^ ^^^^^^
</code></pre>
<blockquote>
<p>Vale notar que caracteres com acentos ou <code>-</code> são considerados <strong>bordas</strong>.</p>
</blockquote>
<p>Podemos lidar com o <strong>início</strong> e <strong>fim</strong> de uma linha. Usamos a meta <code>^</code> para indicar o <strong>início</strong> de uma linha e <code>$</code> indicando o <strong>fim</strong> de uma linha. Algo importante a se notar é que para as âncoras funcionarem a cada quebra de linha <code>\n</code> a flag <code>m</code> tem que estar <strong>habilitada</strong>. Segue uma estrofe usando a meta <code>^</code>:</p>
<pre><code>pattern: /^[a-z]*\b/gmi
Quantas chances desperdicei
^^^^^^^
Quando o que eu mais queria
^^^^^^
Era provar pra todo o mundo
^^^
Que eu não precisava provar nada pra ninguém
^^^
</code></pre>
<p>Confira também o uso do meta <code>$</code> em uma estrofe:</p>
<pre><code>pattern: /[a-z]+nto$/gmi
O tempo cobre o chão de verde manto
                              ^^^^^
Que já coberto foi de neve fria,
E em mim converte em choro o doce canto
                                  ^^^^^
</code></pre>
<p>Conseguimos tratar início e final de um texto ao mesmo tempo. Confira um exemplo:</p>
<pre><code>pattern: /^https:\/\/w{3}\.[a-z]+\.com$/gmi
https://google.com.br
https://www.facebook.com
^^^^^^^^^^^^^^^^^^^^^^^^
https://www.voxel.com.br
</code></pre>
<h2>Grupos “()”</h2>
<p>Por fim, temos os grupos que facilita ainda mais nossas regras. Eles nos possibilita a criação de regras isoladas, possibilita a criação de referencias (retrovisores) para o <strong>reuso</strong> da mesma regra em outro local dentro de uma mesmo regex e ainda cria a possibilidade de <strong>validações</strong> dentro da regex. Seu uso é muito <strong>diverso</strong>, dando muito poder ao programador na hora de escrever suas regras. Veja um exemplo:</p>
<pre><code>pattern: /(\d{2})\/?(\d{2})?\/(\d{4})/
string:  Hoje é dia 20/01/2020
matches:            ^^^^^^^^^^
</code></pre>
<p>Uma função muito interessante dos grupos é que quando criamos algum grupo, este grupo é criando uma <strong>referência</strong>, que podemos acessa-lo em funções como o método replace (que vamos ver a frente) ou usar como <strong>retrovisores</strong> (mirror words) para fazer reuso de algum grupo que deu match anteriormente. Vejamos um exemplo baseado no exemplo anterior:</p>
<pre><code>pattern: /\d{2}(\/?)\d{2}?\1\d{4}/g
string:  20/01/2020 25091991 25-09/2000
matches: ^^^^^^^^^^ ^^^^^^^^
</code></pre>
<p>No exemplo acima, veja que criamos o grupo <code>(\/?)</code> e para não repetí-lo em outro momento que necessitamos da mesma regra, usamos o retrovisor <code>\1</code> sendo <code>1</code> é ligado a <code>ordem</code> em que esse grupo foi criado. Podemos criar diversas referências para o reuso de regras.</p>
<blockquote>
<p>Uma dica é se por exemplo usamos um grupo <code>(\w)</code> o seu retrovisor será o caractere que deu match com <code>\w</code>. Ex: \w = R seu \1 sera R.</p>
</blockquote>
<p>Podemos definir grupos que podem ser <strong>ignorados</strong> (non-capturing groups) na hora do match usando a sintaxe <code>(?:)</code>. Vejamos um exemplo:</p>
<pre><code>pattern: /([a-z]*)\s(?:ronaldo)/gi
string:  Cristiano Ronaldo
matches: ^^^^^^^^^^^^^^^^^
</code></pre>
<p>No exemplo acima, só foi <strong>nomeado</strong> um grupo, no caso <code>([a-z]*)</code> pois o grupo <code>(?:ronaldo)</code> foi definido usando <code>(?:)</code> e com isso não conseguimos manipulá-lo.</p>
<p>Com os grupos podemos criar grupos <strong>aninhados</strong> (grupos dentro de grupos). Vejamos um exemplo:</p>
<pre><code>pattern: /((d[io])|(co))([a-z]{2})(do)/gi
string:  ditado colado dosado
matches: ^^^^^^ ^^^^^^ ^^^^^^
</code></pre>
<p>Os grupos possuem <strong>grupos especiais</strong>. Como o positive <strong>lookahead</strong> <code>(?=)</code> e o seu oposto, <strong>negative lookahead</strong> <code>(?!)</code>. Com o positive lookahead podemos <strong>verificar</strong> se <strong>existe</strong> um grupo a frente de uma expressão ou grupo. Vejamos um exemplo:</p>
<pre><code>pattern: /([a-z]+)(?=,)/gi
string:  Penso, logo existo
matches: ^^^^^
</code></pre>
<p>Falamos acima que a regex só dá match em palavras que à sua <strong>frente</strong> possuam virgula. Já o negative lookahead é exatamente o contrário do positive lookahed, ele pegará todos que não fazem parte do grupo especial. Vejamos um exemplo:</p>
<pre><code>pattern: /([a-z]+)(?!,)\b/gi
string:  Penso, logo existo
matches:        ^^^^ ^^^^^^
</code></pre>
<p>Dentro dos grupos especiais ainda temos os <strong>positive lookbehind</strong> e <strong>negative lookbehind</strong>, porém como eles não possuem um bom suporte nos <a href="https://caniuse.com/#feat=js-regexp-lookbehind">browsers</a> decidi deixá-lo de fora deste post, porém pretendo abordá-los em post futuros.</p>
<hr>
<h2>Métodos de regex no js</h2>
<p>O objeto <strong>regex</strong> possui dois métodos: <code>exec</code> e <code>test</code>. Já com string possui 4 métodos: <code>match</code>, <code>replace</code>, <code>search</code> e <code>split</code>. Porém neste post vou me ater somente a 3 métodos: test, match e replace.</p>
<h3>test</h3>
<p>Usado para verificar se uma regex da match com uma string. Ela retorna sempre valor <strong>boolean</strong>. Este método é ideal para fazer <strong>validações</strong> como por exemplo validar se um email, telefone ou data estão corretos. Vejamos um exemplo validando números de telefone:</p>
<pre><code class="language-js">const regex = /(\((\d{2})\)\s?)?(\d{4,5})[-]?(\d{4})/gm

console.log(regex.test("(77) 95684-9783")) //true
console.log(regex.test("(68)90499-9922")) //false
console.log(regex.test("95088-2649")) //true
</code></pre>
<h3>match</h3>
<p>Ele retorna um array, com as string que deram match com a regex. Se não houver valor, ele retorna <strong>null</strong>. Vejamos um exemplo procurando cep validos em um texto:</p>
<pre><code class="language-js">const text = `
- 58204-824
- 69337-978
- 69.938-863
- 7287498
`
const regex = /(\d{2}[.]?\d{3})[-]?(\d{3})/gm
console.log(text.match(regex))
// [ '58204-824', '69337-978', '69.938-863']
</code></pre>
<p>Vejamos acima que o último número não foi pego no match, pois ele não é um cep válido.</p>
<h3>replace</h3>
<p>Usado para <strong>substituir</strong> strings que deram match por uma nova string. Segue um exemplo:</p>
<pre><code class="language-js">const text = "É só o amor, é só o amor Que conhece o que é verdade"
const regex = /o\samor/gi
console.log(text.replace(regex, "a dor"))
//É só a dor, é só a dor Que conhece o que é verdade
</code></pre>
<p>Podemos ainda <strong>manipular</strong> grupos. Vejamos um exemplo:</p>
<pre><code class="language-js">const text = "2019-26-09"
const regex = /(\d{4})-(\d{2})-(\d{2})/g
console.log(text.replace(regex, "$2/$3/$1"))
// 26/09/2019
</code></pre>
<p>Um recurso legal do replace é que podemos passar uma <strong>função</strong> em vez da string de substituição. Isso ainda nos dá mais possibilidades de alteração em algum texto que queremos substituir algo. Vejamos um exemplo:</p>
<pre><code class="language-js">const texto = `
Lista de jogos:
- Red dead redeption 2: R$ 180,00;
- The last of us 2: R$ 199,95;
- Resident Evil 2 remake: R$ 140,50;
`
const regex = /(R\$)\s(\d*,\d*)/gim
const funcao = (match, p1, p2) => {
  const real = parseFloat(p2.replace(/,/g, "."))
  const cotacao = 4.21
  const dolar = (real / cotacao).toFixed(2)
  const result = dolar.toString().replace(/\./g, ",")
  return `US$ ${result}`
}
console.log(texto.replace(regex, funcao))
/*
- Red dead redeption 2: US$ 42,76;
- The last of us 2: US$ 47,49;
- Resident Evil 2 remake: US$ 33,37;
*/
</code></pre>
<hr>
<h2>Conclusão</h2>
<p>Chegamos ao fim, o estudo de regex é muito interessante, sendo que possível fazer muitas coisas em diferentes linguagens. Fiz uma extensa lista de diversos problemas resolvidos com regex, confira abaixo:</p>
<ul>
<li><strong><a href="https://github.com/alexandreservian/regex-cheat-sheet">18 aplicações comuns de regex no dia a dia</a></strong></li>
</ul>
<p>Você ainda pode testar suas regex de forma mais visual pelos sites:</p>
<ul>
<li><strong><a href="https://regex101.com/">Regex101</a></strong></li>
<li><strong><a href="https://jex.im/regulex/#!flags=&#x26;re=%5E(a%7Cb)*%3F%24">Regulex</a></strong></li>
</ul>
<p>Este é meu primeiro post, espero que tenha ajudado. Vlws.</p>
<h3>Referências:</h3>
<ul>
<li><a href="https://flaviocopes.com/javascript-regular-expressions/">A guide to JavaScript Regular Expressions</a></li>
<li><a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc">20 Small Steps to Become a Regex Master</a></li>
<li><a href="https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285">Regex tutorial — A quick cheatsheet by examples</a></li>
</ul></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-167518852-1', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/regex-um-guia-pratico-para-expressoes-regulares";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-7c6c550acc932a22ff69.js"],"component---src-pages-404-js":["/component---src-pages-404-js-5642da255a39a68722cf.js"],"component---src-pages-index-js":["/component---src-pages-index-js-20eee8734e419d248160.js"],"component---src-templates-post-index-js":["/component---src-templates-post-index-js-a71a4067e82206d7c3bb.js"]};/*]]>*/</script><script src="/component---src-templates-post-index-js-a71a4067e82206d7c3bb.js" async=""></script><script src="/app-7c6c550acc932a22ff69.js" async=""></script><script src="/framework-e84382e1b96b75949e61.js" async=""></script><script src="/webpack-runtime-72a1a1ce12b6759a1f7f.js" async=""></script></body></html>