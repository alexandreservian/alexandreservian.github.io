{"componentChunkName":"component---src-templates-post-index-js","path":"/regex-um-guia-pratico-para-expressoes-regulares","result":{"data":{"markdownRemark":{"html":"<p>Em toda nossa vida como programadores estaremos lidando com <strong>regex</strong> em algum momento. Seja para coisas comuns como <strong>validar</strong> emails ou data e até mesmo para fazer <strong>parse</strong> em textos em busca de um determinado padrão.</p>\n<p>Nesse post, irei mostrar de forma simples e fácil como você pode criar suas próprias expressões regulares. Todos os exemplos serão feitos usando <strong>javascript</strong>, porém, muito das regex criadas aqui também funcionarão em outras linguagens como <strong>elixir</strong>, <strong>python</strong>, <strong>php</strong> ou <strong>ruby</strong>.</p>\n<hr>\n<h2>O que é uma expressão regular?</h2>\n<p>De forma simples:</p>\n<blockquote>\n<p>Uma expressão regular é um método formal de se especificar um padrão de texto.</p>\n</blockquote>\n<p>Com ela podemos lidar com as seguintes situações:</p>\n<ul>\n<li>procura;</li>\n<li>substituição;</li>\n<li>validação de formatos;</li>\n<li>filtragem de informações</li>\n</ul>\n<h2>Criando nossas primeiras regex</h2>\n<p>Usando javascript podemos optar por duas formas de se criar uma regex. Podemos criar usando um <strong>constructor</strong>:</p>\n<pre><code class=\"language-js\">const regex = new RegExp(\"dog\", \"gi\")\n</code></pre>\n<p>Ou criando de forma <strong>literal</strong>:</p>\n<pre><code class=\"language-js\">const regex = /dog/gi\n</code></pre>\n<p>Podemos buscar por somente uma letra:</p>\n<pre><code>pattern: /a/\nstring:  A casa está limpa.\nmatches:    ^\n</code></pre>\n<p>Ou buscar por uma palavra:</p>\n<pre><code>pattern: /celular/\nstring:  O celular está tocando.\nmatches:   ^^^^^^^\n</code></pre>\n<p>Podemos ver que, na primeira regex, ela ignorou o primeiro <strong>A</strong>. Isso acontece porque as regex são <strong>case sensitive</strong>. Notamos também na primeira regex que só houve <strong>match</strong> na primeira ocorrência. Para lidar com isso, usaremos <strong>flags</strong>.</p>\n<h2>Flags</h2>\n<p>Elas adicionam comportamentos adicionais a nossas regras, como:</p>\n<ul>\n<li><code>g</code> - indicar achar todas as ocorrências da regex</li>\n<li><code>i</code> - ignora case sensitive</li>\n<li><code>m</code> - multilinha, lida com caracteres de inicio e fim <code>(^ e \\$)</code> ao operar em múltiplas linhas.</li>\n</ul>\n<p>Podemos então obter todas as <strong>ocorrências</strong> com a flag <code>g</code> e em conjunto com a flag <code>i</code> podemos ignorar o <strong>case sensitive</strong> de uma busca:</p>\n<pre><code>pattern: /ontem/gi\nstring: Ontem faltou água, Anteontem faltou luz\nmatches:^^^^^                  ^^^^^\n</code></pre>\n<h2>Operador pipe \"|“</h2>\n<p>Algumas vezes precisamos dar match em mais de <strong>um</strong> termo, para isso usamos o operador pipe <code>|</code> . Ele funciona basicamente como nosso operador lógico <strong>OR</strong> <code>||</code>. Assim podemos escrever:</p>\n<pre><code>pattern: /ver|distrai/gi\nstring: Ver a linha do horizonte me distrai\nmatches:^^^                         ^^^^^^^\n\npattern: /20|nove/gi\nstring: Perdi 20 em 20 e nove amizades\nmatches:      ^^    ^^   ^^^^\n\npattern: /e|m|²/gi\nstring:  E = mc²\nmatches: ^   ^ ^\n</code></pre>\n<h2>Conjuntos “[]”</h2>\n<p>Com os conjuntos dizemos a regex que uma determinada casa pode ter diversos valores para dar match. Vejamos o seu uso:</p>\n<pre><code>pattern: /[em²]/gi\nstring:  E = mc²\nmatches: ^   ^ ^\n</code></pre>\n<p>Uma funcionalidade interessante é de adicionar <strong>range</strong> (invervalos) dentro dos nossos conjuntos. Podemos determinar um conjunto de match em letras que vão de <strong>A</strong> à <strong>Z</strong> ou pegue qualquer digito <strong>(0 à 9)</strong>.</p>\n<pre><code>pattern: /[a-z]/\nstring:  João de Santo Cristo\nmatches:  ^ ^ ^^  ^^^^  ^^^^^\n\npattern: /[A-Za-z]/\nstring:  Açucar e Café\nmatches: ^ ^^^^ ^  ^^\n\npattern: /[0-9.,]/\nstring:  Um ps4 custa R$ 1.600,00\nmatches:      ^          ^^^^^^^^\n</code></pre>\n<p>Um detalhe a ser observado é que o <strong>range</strong> obedece a mesma ordem da tabela <strong><a href=\"https://unicode-table.com/pt/\">Unicode</a></strong>, sendo assim regex como <code>[a-Z]</code> ou <code>[4-1]</code> produziram <strong>erro</strong>, pois ambas não estão na ordem correta da tabela Unicode.</p>\n<p>Podemos também dar match em letras com <strong>acentos</strong> (é-à) ou (ç) usando:</p>\n<pre><code>pattern: /[À-ü]/\nstring:  Açaí é melhor\nmatches: ^^^^ ^ ^^^^^^\n</code></pre>\n<p>Temos também os <strong>conjuntos negados</strong>, que como o nome sugere, dar match em tudo que não faça parte do conjunto. Para definí-lo iniciamos a regra do conjunto com <code>^</code> , por exemplo <code>[^a-z]</code> que aceita tudo que não seja entre <strong>a</strong> à <strong>z</strong>. Vejamos um exemplo:</p>\n<pre><code>pattern: /[^aeiouí]/gi\nstring:  Paralelepípedo\nmatches: ^ ^ ^ ^ ^ ^ ^\n</code></pre>\n<h2>Metacaracteres</h2>\n<p>Nas regex existem duas formas de caracteres, os <strong>literais</strong>, que representam o valor literal do caractere como <code>abc123</code> e os <strong>metacaracteres</strong> que possuem funções distintas dentro de um contexto na regex. Dois exemplos que acabamos de ver são o uso do <code>^</code> iniciando um conjunto negado e o uso do <code>-</code> em uma regra de conjunto com range <code>[1-9]</code>. Um metacaractere bastante recorrente é o <strong>ponto</strong> <code>.</code>, ele funciona como um <strong>coringa</strong>, sendo capaz de dar match em qualquer caractere, vejamos um exemplo:</p>\n<pre><code>pattern: /cas./gi\nstring:  Casa, caso, case\nmatches: ^^^^  ^^^^  ^^^^\n</code></pre>\n<p>Visto isso, você deve estar se perguntando: Como pegar a forma <strong>literal</strong> do ponto? Eis que é muito simples bastando usar um <strong>escape</strong> <code>\\</code> mais o metacaractere desejado. Vejamos um exemplo:</p>\n<pre><code>pattern: /[a\\-o]/gi\nstring:  cachorro-quente.\nmatches:  ^  ^  ^^\n</code></pre>\n<p>Para simplificar a escrita e leitura das regex, possuímos algumas <strong>shorthands</strong> que são extremamente úteis para deixar ainda mais claro nosso código. Veja como podemos escrever esse conjunto <code>[0-9]</code> para <code>\\d</code>, <code>[a-zA-Z0-9_]</code> para <code>\\w</code> ou para tratar espaços em branco <code>[\\r\\n\\t\\f\\v ]</code> para <code>\\s</code> simplificando ainda mais nossas regras. Vejamos alguns exemplos:</p>\n<pre><code>pattern: /\\(\\d\\d\\)\\s\\d\\d\\d\\d\\d-\\d\\d\\d\\d/\nstring:  (86) 95262-7297\nmatches: ^^^^^^^^^^^^^^^\n\npattern: /\\w\\w\\w\\w\\w@\\w\\w\\.com/\nstring:  ax_a5@5x.com\nmatches: ^^^^^^^^^^^^\n</code></pre>\n<p>Para um guia de consulta, criei um <strong><a href=\"https://gist.github.com/alexandreservian/124db2fab8a75474dd6fdc4f17f93a5d\">gist</a></strong> contendo muitos <strong>metacaracteres</strong> e shorthands e seus respectivos significado.</p>\n<h2>Quantificadores</h2>\n<p>Uma maneira de deixar suas regras ainda mais simples é com o uso dos quantificadores. Com eles podemos dizer quantas vezes uma <strong>mesma</strong> regra pode aparecer em <strong>sequência</strong>. Vejamos elas:</p>\n<ul>\n<li><code>?</code> - zero ou um ocorrência;</li>\n<li><code>*</code> - zero ou mais ocorrências;</li>\n<li><code>+</code> - uma ou mais ocorrências;</li>\n<li><code>{n, m}</code> - de n até m.</li>\n</ul>\n<blockquote>\n<p>Seu uso é simples, basta adicionar o quantificador após um caractere, metacaractere, conjunto ou mesmo um grupo (ainda veremos abaixo). Exemplo <code>[0-9]?</code> <code>\\w\\*</code> <code>a+</code> e <code>(\\d){1,3}</code>.</p>\n</blockquote>\n<p>Digamos que queremos pegar um documento como o <strong>cpf</strong>, que contêm muitos números e pontuações(<code>.</code> e <code>-</code>) onde a validação pode aceitar o cpf com e sem pontuação, ficando deste modo:</p>\n<pre><code>pattern: /\\d{3}\\.?\\d{3}\\.?\\d{3}-?\\d{2}/\nstring:  825.531.760-07\nmatches: ^^^^^^^^^^^^^^\nstring:  18646661024\nmatches: ^^^^^^^^^^^\n</code></pre>\n<p>Como podemos pegar uma repetição de caractere sem estipular algum limite, vejamos:</p>\n<pre><code>pattern: /go+l+/gi\nstring:  Goolllll da Alemanha!!!\nmatches: ^^^^^^^^\n</code></pre>\n<h2>Âncoras</h2>\n<p>Muitas vezes vamos precisar <strong>delimitar</strong> a ação da nossa regex. Desse modo podemos usar três metas para nos auxiliar nessa função.</p>\n<p>Quando queremos tratar uma <strong>palavra</strong> que em suas extremidades não possua outra letra ou palavra, usamos a shorthands <code>\\b</code>.</p>\n<pre><code>pattern: /\\bpar\\b/gi\nstring:  Parcela par Parcial paraíso\nmatches:         ^^^\n\npattern: /\\bpar[a-z]+/gi\nstring:  Parei parque topar\nmatches: ^^^^^ ^^^^^^\n\npattern: /[a-z]+par\\b/gi\nstring:  parodiado escapar equipar parasitar\nmatches:           ^^^^^^^ ^^^^^^^\n\npattern: /\\b[a-z]+par[a-z]+\\b/gi\nstring:  limpar aparto aparta\nmatches:        ^^^^^^ ^^^^^^\n</code></pre>\n<blockquote>\n<p>Vale notar que caracteres com acentos ou <code>-</code> são considerados <strong>bordas</strong>.</p>\n</blockquote>\n<p>Podemos lidar com o <strong>início</strong> e <strong>fim</strong> de uma linha. Usamos a meta <code>^</code> para indicar o <strong>início</strong> de uma linha e <code>$</code> indicando o <strong>fim</strong> de uma linha. Algo importante a se notar é que para as âncoras funcionarem a cada quebra de linha <code>\\n</code> a flag <code>m</code> tem que estar <strong>habilitada</strong>. Segue uma estrofe usando a meta <code>^</code>:</p>\n<pre><code>pattern: /^[a-z]*\\b/gmi\nQuantas chances desperdicei\n^^^^^^^\nQuando o que eu mais queria\n^^^^^^\nEra provar pra todo o mundo\n^^^\nQue eu não precisava provar nada pra ninguém\n^^^\n</code></pre>\n<p>Confira também o uso do meta <code>$</code> em uma estrofe:</p>\n<pre><code>pattern: /[a-z]+nto$/gmi\nO tempo cobre o chão de verde manto\n                              ^^^^^\nQue já coberto foi de neve fria,\nE em mim converte em choro o doce canto\n                                  ^^^^^\n</code></pre>\n<p>Conseguimos tratar início e final de um texto ao mesmo tempo. Confira um exemplo:</p>\n<pre><code>pattern: /^https:\\/\\/w{3}\\.[a-z]+\\.com$/gmi\nhttps://google.com.br\nhttps://www.facebook.com\n^^^^^^^^^^^^^^^^^^^^^^^^\nhttps://www.voxel.com.br\n</code></pre>\n<h2>Grupos “()”</h2>\n<p>Por fim, temos os grupos que facilita ainda mais nossas regras. Eles nos possibilita a criação de regras isoladas, possibilita a criação de referencias (retrovisores) para o <strong>reuso</strong> da mesma regra em outro local dentro de uma mesmo regex e ainda cria a possibilidade de <strong>validações</strong> dentro da regex. Seu uso é muito <strong>diverso</strong>, dando muito poder ao programador na hora de escrever suas regras. Veja um exemplo:</p>\n<pre><code>pattern: /(\\d{2})\\/?(\\d{2})?\\/(\\d{4})/\nstring:  Hoje é dia 20/01/2020\nmatches:            ^^^^^^^^^^\n</code></pre>\n<p>Uma função muito interessante dos grupos é que quando criamos algum grupo, este grupo é criando uma <strong>referência</strong>, que podemos acessa-lo em funções como o método replace (que vamos ver a frente) ou usar como <strong>retrovisores</strong> (mirror words) para fazer reuso de algum grupo que deu match anteriormente. Vejamos um exemplo baseado no exemplo anterior:</p>\n<pre><code>pattern: /\\d{2}(\\/?)\\d{2}?\\1\\d{4}/g\nstring:  20/01/2020 25091991 25-09/2000\nmatches: ^^^^^^^^^^ ^^^^^^^^\n</code></pre>\n<p>No exemplo acima, veja que criamos o grupo <code>(\\/?)</code> e para não repetí-lo em outro momento que necessitamos da mesma regra, usamos o retrovisor <code>\\1</code> sendo <code>1</code> é ligado a <code>ordem</code> em que esse grupo foi criado. Podemos criar diversas referências para o reuso de regras.</p>\n<blockquote>\n<p>Uma dica é se por exemplo usamos um grupo <code>(\\w)</code> o seu retrovisor será o caractere que deu match com <code>\\w</code>. Ex: \\w = R seu \\1 sera R.</p>\n</blockquote>\n<p>Podemos definir grupos que podem ser <strong>ignorados</strong> (non-capturing groups) na hora do match usando a sintaxe <code>(?:)</code>. Vejamos um exemplo:</p>\n<pre><code>pattern: /([a-z]*)\\s(?:ronaldo)/gi\nstring:  Cristiano Ronaldo\nmatches: ^^^^^^^^^^^^^^^^^\n</code></pre>\n<p>No exemplo acima, só foi <strong>nomeado</strong> um grupo, no caso <code>([a-z]*)</code> pois o grupo <code>(?:ronaldo)</code> foi definido usando <code>(?:)</code> e com isso não conseguimos manipulá-lo.</p>\n<p>Com os grupos podemos criar grupos <strong>aninhados</strong> (grupos dentro de grupos). Vejamos um exemplo:</p>\n<pre><code>pattern: /((d[io])|(co))([a-z]{2})(do)/gi\nstring:  ditado colado dosado\nmatches: ^^^^^^ ^^^^^^ ^^^^^^\n</code></pre>\n<p>Os grupos possuem <strong>grupos especiais</strong>. Como o positive <strong>lookahead</strong> <code>(?=)</code> e o seu oposto, <strong>negative lookahead</strong> <code>(?!)</code>. Com o positive lookahead podemos <strong>verificar</strong> se <strong>existe</strong> um grupo a frente de uma expressão ou grupo. Vejamos um exemplo:</p>\n<pre><code>pattern: /([a-z]+)(?=,)/gi\nstring:  Penso, logo existo\nmatches: ^^^^^\n</code></pre>\n<p>Falamos acima que a regex só dá match em palavras que à sua <strong>frente</strong> possuam virgula. Já o negative lookahead é exatamente o contrário do positive lookahed, ele pegará todos que não fazem parte do grupo especial. Vejamos um exemplo:</p>\n<pre><code>pattern: /([a-z]+)(?!,)\\b/gi\nstring:  Penso, logo existo\nmatches:        ^^^^ ^^^^^^\n</code></pre>\n<p>Dentro dos grupos especiais ainda temos os <strong>positive lookbehind</strong> e <strong>negative lookbehind</strong>, porém como eles não possuem um bom suporte nos <a href=\"https://caniuse.com/#feat=js-regexp-lookbehind\">browsers</a> decidi deixá-lo de fora deste post, porém pretendo abordá-los em post futuros.</p>\n<hr>\n<h2>Métodos de regex no js</h2>\n<p>O objeto <strong>regex</strong> possui dois métodos: <code>exec</code> e <code>test</code>. Já com string possui 4 métodos: <code>match</code>, <code>replace</code>, <code>search</code> e <code>split</code>. Porém neste post vou me ater somente a 3 métodos: test, match e replace.</p>\n<h3>test</h3>\n<p>Usado para verificar se uma regex da match com uma string. Ela retorna sempre valor <strong>boolean</strong>. Este método é ideal para fazer <strong>validações</strong> como por exemplo validar se um email, telefone ou data estão corretos. Vejamos um exemplo validando números de telefone:</p>\n<pre><code class=\"language-js\">const regex = /(\\((\\d{2})\\)\\s?)?(\\d{4,5})[-]?(\\d{4})/gm\n\nconsole.log(regex.test(\"(77) 95684-9783\")) //true\nconsole.log(regex.test(\"(68)90499-9922\")) //false\nconsole.log(regex.test(\"95088-2649\")) //true\n</code></pre>\n<h3>match</h3>\n<p>Ele retorna um array, com as string que deram match com a regex. Se não houver valor, ele retorna <strong>null</strong>. Vejamos um exemplo procurando cep validos em um texto:</p>\n<pre><code class=\"language-js\">const text = `\n- 58204-824\n- 69337-978\n- 69.938-863\n- 7287498\n`\nconst regex = /(\\d{2}[.]?\\d{3})[-]?(\\d{3})/gm\nconsole.log(text.match(regex))\n// [ '58204-824', '69337-978', '69.938-863']\n</code></pre>\n<p>Vejamos acima que o último número não foi pego no match, pois ele não é um cep válido.</p>\n<h3>replace</h3>\n<p>Usado para <strong>substituir</strong> strings que deram match por uma nova string. Segue um exemplo:</p>\n<pre><code class=\"language-js\">const text = \"É só o amor, é só o amor Que conhece o que é verdade\"\nconst regex = /o\\samor/gi\nconsole.log(text.replace(regex, \"a dor\"))\n//É só a dor, é só a dor Que conhece o que é verdade\n</code></pre>\n<p>Podemos ainda <strong>manipular</strong> grupos. Vejamos um exemplo:</p>\n<pre><code class=\"language-js\">const text = \"2019-26-09\"\nconst regex = /(\\d{4})-(\\d{2})-(\\d{2})/g\nconsole.log(text.replace(regex, \"$2/$3/$1\"))\n// 26/09/2019\n</code></pre>\n<p>Um recurso legal do replace é que podemos passar uma <strong>função</strong> em vez da string de substituição. Isso ainda nos dá mais possibilidades de alteração em algum texto que queremos substituir algo. Vejamos um exemplo:</p>\n<pre><code class=\"language-js\">const texto = `\nLista de jogos:\n- Red dead redeption 2: R$ 180,00;\n- The last of us 2: R$ 199,95;\n- Resident Evil 2 remake: R$ 140,50;\n`\nconst regex = /(R\\$)\\s(\\d*,\\d*)/gim\nconst funcao = (match, p1, p2) => {\n  const real = parseFloat(p2.replace(/,/g, \".\"))\n  const cotacao = 4.21\n  const dolar = (real / cotacao).toFixed(2)\n  const result = dolar.toString().replace(/\\./g, \",\")\n  return `US$ ${result}`\n}\nconsole.log(texto.replace(regex, funcao))\n/*\n- Red dead redeption 2: US$ 42,76;\n- The last of us 2: US$ 47,49;\n- Resident Evil 2 remake: US$ 33,37;\n*/\n</code></pre>\n<hr>\n<h2>Conclusão</h2>\n<p>Chegamos ao fim, o estudo de regex é muito interessante, sendo que possível fazer muitas coisas em diferentes linguagens. Fiz uma extensa lista de diversos problemas resolvidos com regex, confira abaixo:</p>\n<ul>\n<li><strong><a href=\"https://github.com/alexandreservian/regex-cheat-sheet\">18 aplicações comuns de regex no dia a dia</a></strong></li>\n</ul>\n<p>Você ainda pode testar suas regex de forma mais visual pelos sites:</p>\n<ul>\n<li><strong><a href=\"https://regex101.com/\">Regex101</a></strong></li>\n<li><strong><a href=\"https://jex.im/regulex/#!flags=&#x26;re=%5E(a%7Cb)*%3F%24\">Regulex</a></strong></li>\n</ul>\n<p>Este é meu primeiro post, espero que tenha ajudado. Vlws.</p>\n<h3>Referências:</h3>\n<ul>\n<li><a href=\"https://flaviocopes.com/javascript-regular-expressions/\">A guide to JavaScript Regular Expressions</a></li>\n<li><a href=\"https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc\">20 Small Steps to Become a Regex Master</a></li>\n<li><a href=\"https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285\">Regex tutorial — A quick cheatsheet by examples</a></li>\n</ul>","frontmatter":{"date":"January 31, 2020","path":"/regex-um-guia-pratico-para-expressoes-regulares","title":"Regex\":\" Um guia prático para expressões regulares"}}},"pageContext":{}}}